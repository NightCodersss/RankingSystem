\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathtools}
\begin{document}

\section{Система ранжирования}
\section{Разработчику}
Помимо информации, изложенной здесь, следует изучить документацию, сгенерированную doxygen'ом (директории latex и html в корне проекта).

\subsection{Сборка документации}
Команда:
\begin{verbatim}
make doc
\end{verbatim}
Соберет всю документацию (tex в pdf, md; doxygen) и сделает коммит только документации.




\subsubsection{Реализация}
Ясно, что нехорошо ждать каждого ответа. 
Глобально, есть два пути решения этой проблемы: использование асинхронных операций ввода-вывода (с callback'ами) и использование большого количества потоков. Существенных различий нет (нам известных), за исключением того, что код с большим количеством callback'ов плохо читаем и некрасив.

Итак, реализация такова, что на каждое соединение выделется отдельный поток, в котором соединение работает синхронно.

Следует обратить внимание, что конфигурация считывается в json, а не в ubjson.

\subsection{Утилита для генерации рандомного индекса}
Хотим: индекс, ранги документов которого распределны по заданной функции \N\rightarrow (должна быть монотонно убывающей, положительной, ограниченной 1). Коэффициенты каждого документа должны быть больше нуля, линейная комбинация с коэффициентами текстов давать заданный ранг, должны быть из отрезка [0, 1].
Общий алгоритм:
Ранг: $\sum c_i*\lambda_i = (c, \lambda)$
Будем генерировать такие лямбды так: сначала сгенерируем $\lambda_0$, так, чтобы $(c, \lambda_0) = r$ аналитическим методом (по формуле: $\lambda_0=(r, r, ..., r)$ - мы надеемся, что сумма координат вектора c равна 1), после чего прибавить к нему вектор случайный сдвига: $(c, v) = 0, abs(v_i) < abs({\lambda_0}_i)$ (чтобы результирующие коэффициенты были положительными). Но радость в том, что первое условие - это просто условие ортогональности: мы можем сгенерировать случайный вектор и спроецировать его на плоскость, перпендикулярную вектору c.
\end{document}
