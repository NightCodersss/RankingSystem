Система ранжирования
====================

Зависимости
===========

-   C++14

-   UbjsonCpp - библиотека для работы протокола (repo:
    https://github.com/NightCodersss/UbjsonCpp)

-   cppunit - библиотека для unit-тестирования (используется в Ubjson)

-   json - библиотека для чтения конфига (repo:
    https://github.com/nlohmann/json)

Разработчику
============

Помимо информации, изложенной здесь, следует изучить документацию,
сгенерированную doxygen’ом (директории latex и html в корне проекта).

Структура {#subsec:generalStructure}
---------

Структура выглядит так: (Фронт-энд или другой сервис)
$\xrightarrow{Southern protocol}$ Ranking System
$\xrightarrow{Northern protocol}$ IndexServer Где $'\rightarrow'$
обозначет подключение от клиента к серверу.

Протокол
--------

В связи с тем, что Ubjson парсится на лету, не все поля обязательны. В
силу гибкости протокола незначительное изменение или значительное
добавление не должно требовать больших трудов. Что такое южный и
северный легко понять отсюда [subsec:generalStructure].

### Южный

Запрос.

Необходимо передавать строчку query, которая хранит в себе запрос. Поле
$amount$ не обязательно.

    {
        "query": "what is ...?"
        "amount": "1000000"
    }

Ответ.

    {
        "docs": [ {...}, {...}, ],
        "amount": 12243,
    }

Планируется добавить параметры, каким образом представлять информацию о
документе обратно.

Заглушка работает так: слушает некоторый порт, по приходу данных, до
переноса строки ($\backslash n$), приходящие данные пакует в ubjson и
отправляет системе ранжирования. По приходу данных от системы
ранжирования (то есть системы поиска)(в ubjson) заглушка “их отвечает” в
json (обычном).

### Северный

Запрос.

Такой же, как “южный”, но с параметром - какой индекс использовать (по
какому тексту), то есть:

    {
        "query": "what is ...?",
        "index_id": "aa1234df",
        "fields": ["docname", "author", "smallpartoftext"],
    }

Ответ.

Такой же, как у южного.

### Реализация

Ясно, что нехорошо ждать каждого ответа. Глобально, есть два пути
решения этой проблемы: использование асинхронных операций ввода-вывода
(с callback’ами) и использование большого количества потоков.
Существенных различий нет (нам известных), за исключением того, что код
с большим количеством callback’ов плохо читаем и некрасив.

Итак, реализация такова, что на каждое соединение выделется отдельный
поток, в котором соединение работает синхронно.

Конфигурация
------------

Следует обратить внимание, что конфигурация считывается в json, а не в
ubjson. См. “конфигурация” для человека, который запускает.

Программистам-пользователям
===========================

См. структуру [subsec:generalStructure]

Человеку, который запускает
===========================

См. структуру [subsec:generalStructure]

Конфигурация
------------

Пример конфига RankingServer’а:

    {
        "texts": [
            {
                "servers": [{"host": "localhost", "port": "14000"}],
                "factor": 1.8,
                "name": "The first text field",
                "index_id": "1",
            },
            {
                "servers": [{"host": "", "port": "14000"}],
                "factor": 0.9,
                "name": "Useless information",
                "index_id": "100400ab",
            },
        ]
    }
